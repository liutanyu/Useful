;; This file is free software,which comes along with the scheme package. This
;; software  is  distributed  in the hope that it will be useful, but WITHOUT 
;; ANY  WARRANTY;  without  even  the  implied warranty of MERCHANTABILITY or
;; FITNESS  FOR A PARTICULAR PURPOSE. You can modify it as you want, provided
;; this header is kept unaltered, and a notification of the changes is added.
;; You  are  allowed  to  redistribute  it and sell it, alone or as a part of 
;; another product.
;;          Copyright (C) 1998-99 Stephane HILLION - hillion@essi.fr
;;              http://www.essi.fr/~hillion/scheme-package
;;
;;
;; Java interface file generator
;;
;; Stephane Hillion - 1998/12/22
;;
(require 'jobject)
(require 'list)
(require 'control)

(define <java-maker> (<class> make <object> 
			      (.path      ;; The output path
			       .class     ;; The class name  (symbol)
			       .name      ;; The java name   (string)
			       .parent    ;; The parent name (symbol)
			       .L         ;; The class specification (list)
			       .out       ;; The output port
			       )))

(<java-maker> define (init path)
	      ;; Initialization. path is a string containing the
	      ;; output directory path
	      (set! .path path))

(provide 'java-maker)

;; Utility functions -----------------------------------------------

(define get-name             car)
(define get-java-name        cadr)
(define get-parent           caddr)
(define get-constructors     cadddr)
(define (get-fields L)       (car (cddddr L)))
(define (get-methods L)      (cadr (cddddr L)))

;; methods ---------------------------------------------------------

(<java-maker> define (create-class L)
	      ;; Creates a new class definition
	      ;; L must have the following form:
	      ;;    (<class-name> "java-name" <parent-name>
              ;;      (constructor ...)
	      ;;      (field ...)
	      ;;      (method ...))
	      ;;
	      ;; constructor:
	      ;;    (param1-class ...)
	      ;;
	      ;; field:
	      ;;    (name field-class "java-name")
	      ;; or (name static field-class "java-name")
	      ;; or (name final field-class "java-name")
	      ;; or (name final static field-class "java-name")
	      ;;
	      ;; method:
	      ;;    (name "java-name" method-spec ...)
	      ;;
	      ;; method-spec:
	      ;;    (() param1-class param2-class ...)
	      ;; or ((return-class) param1-class param2-class ...)
	      ;; or (static () param1-class param2-class ...)
	      ;; or (static (return-class) param1-class param2-class ...)
	      ;;
	      (set! .class  (get-name  L))
	      (set! .name   (get-java-name L))
	      (set! .parent (get-parent L))
	      (set! .L      L)

	      (this open-output)
	      (this write-header)
	      (this write-requires)
	      (this write-constructor)
	      (this write-fields)
	      (this write-methods)
	      )

(<java-maker> define (open-output)
	      ;; Opens the output port
	      (let* ((str   (symbol->string .class))
		     (fname (string-append .path 
			       (substring str 1 (-1+ (string-length str)))
			       ".scm")))
		(set! .out (open-output-file fname))))

(<java-maker> define (file-name symb)
	      ;; Returns the file name corresponding to a class name
	      (let ((str (symbol->string symb)))
		(substring str 1 (-1+ (string-length str)))))

(<java-maker> define (write-header)
	      ;; Writes the class definition in the output file
	      (display ";; File generated by <java-maker>" .out)
	      (newline .out)
	      (display ";;" .out)
	      (newline .out)
	      (display "(require '" .out)
	      (display (this file-name .parent) .out)
	      (display ")" .out)
	      (newline .out)
	      (newline .out)
 	      (write `(define ,.class (,.parent create-java-class ,.name)) .out)
 	      (newline .out)
 	      (newline .out)
	      (display "(provide '" .out)
	      (display (this file-name .class) .out)
	      (display ")" .out)
	      (newline .out))

(<java-maker> define (write-requires)
	      ;; Writes all (require ...) forms needed in the output file
	      (map (lambda (c)
		     (display "(require '" .out)
		     (display (this file-name c) .out)
		     (display ")" .out)
		     (newline .out))
		   (set-difference 
		    (list->set (append (this constructor-classes)
				       (this field-classes)
				       (this method-classes)))
		    `(,.class ,.parent
			      <jchar>
			      <jstring>
			      <jbyte>
			      <jint>
			      <jlong>
			      <jbool>
			      <jfloat>
			      <jdouble>))))

(<java-maker> define (constructor-classes)
	      ;; Returns the list of all classes used in the constructor clause
	      (apply append (get-constructors .L)))

(<java-maker> define (field-classes)
	      ;; Returns the list of the classes used in the field clause
	      (let ((res '()))
		(for-each (lambda (l)
			    (cond ((eq? (cadr l) 'final)
				   (if (eq? (caddr l) 'static)
				       (set! res (cons (cadddr l) res))
				       (set! res (cons (caddr l) res))))
				  ((eq? (cadr l) 'static)
				   (set! res (cons (caddr l) res)))
				  (else
				   (set! res (cons (cadr l) res)))))
			  (get-fields .L))
		res))

(<java-maker> define (method-classes)
	      ;; Returns the list of the classes used in the method clause
	      (let ((res '()))
		(for-each
		 (lambda (l)
		   (for-each
		    (lambda (p)
		      (for-each (lambda (s)
				  (cond ((pair? s)
					 (set! res (cons (car s) res)))
					((and (not (null? s))
					      (not (eq? s 'static)))
					 (set! res (cons s res)))))
				p))
		    (cddr l)))
		 (get-methods .L))
		res))

(<java-maker> define (write-constructor)
	;; Writes the constructor definition in the output file
        (let* ((lc  (get-constructors .L))
	       (cpt 0)
	       (gs  (lambda ()
		      (string->symbol (string-append "C" (number->string cpt))))))
	  (when (not (null? lc))
		(newline .out)
		(display ";; Constructor --------------------------------" .out)
		(newline .out)
		(display "(" .out)
		(display .class .out)
		(display " define init" .out)
		(newline .out)
		(if (null? (cdr lc))
		    (begin
		      (display "  " .out)
		      (write `(,.class create-init ,@(car lc)) .out)
		      (display ")" .out)
		      (newline .out))
		    (begin
		      (display "  (let (" .out)
		      (for-each (lambda (L)
				  (set! cpt (1+ cpt))
				  (write `(,(gs) (,.class create-init ,@L)) .out)
				  (newline .out)
				  (display "        " .out))
				lc)
		      (set! cpt 0)
		      (for-each (lambda (L)
				  (set! cpt (1+ cpt))
				  (display "(" .out)
				  (display (gs) .out)
				  (display "? " .out)
				  (if (null? L)
				      (display "null?)" .out)
				      (begin
					(display "(lambda (L) (apply and " .out)
					(newline .out)
					(display "           " .out)
					(display "(map (<jobject> get instance-of?) L "
						 .out)
					(write (cons 'list L) .out)
					(display "))))" .out)))
				  (newline .out)
				  (display "        " .out))
				lc)
                      (display ")" .out)
		      (newline .out)
		      (display "    (method L" .out)
		      (newline .out)
		      (display "      (cond " .out)
		      (set! cpt 0)
		      (for-each (lambda (L)
				  (set! cpt (1+ cpt))
				  (display "((" .out)
				  (display (gs) .out)
				  (display "? L) (apply " .out)
				  (display (gs) .out)
				  (display " this L))" .out)
				  (newline .out)
				  (display "            " .out))
				lc)
		      (display "(else (error '" .out)
		      (display .class .out)
		      (display " \" bad constructor parameters: \" L))))))" .out)
		      (newline .out))))))

(<java-maker> define (write-fields)
	      ;; Writes all field definitions in the output file
	      (newline .out)
	      (display ";; Fields --------------------------------------" .out)
	      (for-each (lambda (L)
			  (this write-field L))
			(get-fields .L)))

(<java-maker> define (write-field L)
	      ;; Writes the field specified by L
	      (newline .out)
	      (if (eq? (cadr L) 'final)
		  (begin
		    (display "(" .out)
		    (display .class .out)
		    (display " define get-" .out)
		    (display (car L) .out)
		    (newline .out)
		    (display "  (" .out)
		    (display .class .out)
		    (if (eq? (caddr L) 'static)
			(begin
			  (display " create-final-static-field " .out)
			  (display (cadddr L) .out)
			  (display " " .out)
			  (write (car (cddddr L)) .out))
			(begin
			  (display " create-final-field " .out)
			  (display (caddr L) .out)
			  (display " " .out)
			  (write (cadddr L) .out)))
		    (display "))" .out))
		  (begin
		    (display "(let ((get.set (" .out)
		    (display .class .out)
		    (if (eq? (cadr L) 'static)
			(begin
			  (display " create-static-field " .out)
			  (display (caddr L) .out)
			  (display " " .out)
			  (write (cadddr L) .out))
			(begin
			  (display " create-field " .out)
			  (display (cadr L) .out)
			  (display " " .out)
			  (write (caddr L) .out)
			))
		    (display ")))" .out)
		    (newline .out)
		    (display "  (" .out)
		    (display .class .out)
		    (display " define get-" .out)
		    (display (car L) .out)
		    (display " (car get.set))" .out)
		    (newline .out)
		    (display "  (" .out)
		    (display .class .out)
		    (display " define set-" .out)
		    (display (car L) .out)
		    (display "! (cdr get.set)))" .out)))
	      (newline .out))

(<java-maker> define (write-methods)
	      ;; Writes all method definitions in the ouput file
	      (newline .out)
	      (display ";; Methods -------------------------------------" .out)
	      (for-each (lambda (L)
			  (this write-method L))
			(get-methods .L)))

(<java-maker> define (write-method L)
	;; Writes the method specified by L
	(let* ((cpt 0)
	       (gs  (lambda ()
		      (string->symbol (string-append "M" (number->string cpt)))))
	       (Lp  (lambda (P)
		      (if (null? (car P))
			  (cons '*java-null* (cons (cadr L) (cdr P)))
			  (cons (caar P) (cons (cadr L) (cdr P)))))))
	  (newline .out)
	  (display "(" .out)
	  (display .class .out)
	  (display " define " .out)
	  (display (car L) .out)
	  (newline .out)
	  (if (null? (cdddr L))
	      (begin
		(display "  " .out)
		(if (eq? (caaddr L) 'static)
		    (write `(,.class create-static-method ,@(Lp (cdaddr L))) .out)
		    (write `(,.class create-method ,@(Lp (caddr L))) .out))
		(display ")" .out)
		(newline .out))
	      (begin
		(display "  (let (" .out)
		(for-each (lambda (P)
			    (set! cpt (1+ cpt))
			    (if (eq? (car P) 'static)
				(write `(,(gs) (,.class create-static-method
							,@(Lp (cdr P)))) .out)
				(write `(,(gs) (,.class create-method
							,@(Lp P))) .out))
			    (newline .out)
			    (display "        " .out))
			  (cddr L))
		(set! cpt 0)
		(for-each (lambda (P)
			    (set! cpt (1+ cpt))
			    (display "(" .out)
			    (display (gs) .out)
			    (display "? " .out)
			    (if (null? (cdr P))
				(display "null?)" .out)
				(begin
				  (display "(lambda (L) (apply and " .out)
				  (newline .out)
				  (display "           " .out)
				  (display "(map (<jobject> get instance-of?) L " .out)
				  (write (cons 'list (cdr P)) .out)
				  (display "))))" .out)))
			    (newline .out)
			    (display "        " .out))
			  (cddr L))
		(display ")" .out)
		(newline .out)
		(display "    (method L" .out)
		(newline .out)
		(display "      (cond " .out)
		(set! cpt 0)
		(for-each (lambda (P)
			    (set! cpt (1+ cpt))
			    (display "((" .out)
			    (display (gs) .out)
			    (display "? L) (apply " .out)
			    (display (gs) .out)
			    (display " this L))" .out)
			    (newline .out)
			    (display "            " .out))
			  (cddr L))
		(display "(else (error '" .out)
		(display .class .out)
		(display " '" .out)
		(display (car L) .out)
		(display " \" bad method parameters: \" L))))))" .out)
		(newline .out)))))
